/* src/index.ts
	Main module file, contains API function(s) and exports types */

// Import required types/functions
import { walkPaths, PathInfo } from "./filewalker";
import { composite, OutputType, TilemapInfo, ResizeFit, ResizeKernel } from "./compositor";
import {
	layoutList, layoutSequences, layoutAnimations,
	Layout, SequenceLayout, AnimationLayout,
	LayoutOptions, ListLayoutOptions, SequenceLayoutOptions, AnimationLayoutOptions
} from "./layouts";
import { LogHandlerConfig, logger } from "./log";

// Export important types
export {
	Layout, SequenceLayout, AnimationLayout,
	LayoutOptions, ListLayoutOptions, SequenceLayoutOptions, AnimationLayoutOptions
} from "./layouts";
export { OutputType, ResizeFit, ResizeKernel } from "./compositor";
export { LogHandlerCallback, LogHandlerConfig } from "./log";

/** Layout mode to use when generating the tileset/tilemap from all the input images. */
export enum LayoutMode {
	/** Generate a tilemap layout in the simplest manner possible, just put all input tiles in a continuous list going from left to right, looping back to the next line once "width" is reached. */
	ListLayout = "list",
	/** Generate a tilemap layout that contains "sequences". Each "sequence" is a continuos list of frames, usually for an animation. Each folder in the inputted paths will be treated as a new sequence. */
	SequenceLayout = "sequence",
	/**
	 * Advanced. Generate a tilemap layout that contains "animations", where each animation has sub-sequences for different angles.
	 * This will take a file structure like:
	 * ```
	 * root/
	 *   anim1/
	 *     0/   [frame1.png, frame2.png, frame3.png]
	 *     90/  [frame1.png, frame2.png, frame3.png]
	 *     180/ [frame1.png, frame2.png, frame3.png]
	 *     270/ [frame1.png, frame2.png, frame3.png]
	 *   anim2/
	 *     0/   [frame1.png, frame2.png, frame3.png]
	 *     90/  [frame1.png, frame2.png, frame3.png]
	 *     180/ [frame1.png, frame2.png, frame3.png]
	 *     270/ [frame1.png, frame2.png, frame3.png]
	 * ```
	 * And output something like:
	 * ```json
	 * {
	 *   "animations": [
	 *     {
	 *       "name": "anim1",
	 *       "angles": [
	 *         { ... },
	 *         { ... },
	 *         { ... },
	 *         { ... }
	 *       ]
	 *     },
	 *     {
	 *       "name": "anim2",
	 *       "angles": [
	 *         { ... },
	 *         { ... },
	 *         { ... },
	 *         { ... }
	 *       ]
	 *     }
	 *   ]
	 * }
	 * ```
	 */
	AnimationLayout = "animation"
}

/** Tilemapper options. "paths", "layoutMode", and "outputType" are required. All other options are, well, optional! */
export interface TilemapperOptions<LM> extends Partial<LayoutOptions & ListLayoutOptions & SequenceLayoutOptions & AnimationLayoutOptions> {
	/**
	 * Paths to search for images.
	 * Required.
	 */
	paths?: string | string[],
	/**
	 * Supported image extensions.
	 * Default value: `["png", "jpg", "jpeg", "gif", "webp", "tiff", "svg"]`
	 */
	extensions?: string[],
	/**
	 * Working directory (used when generating dirnames).
	 * Default value: `process.cwd()`
	 */
	workingDirectory?: string,

	/**
	 * Layout mode to use.
	 * Required.
	 */
	layoutMode?: LM,

	/**
	 * Output file data type.
	 * Required.
	 */
	outputType?: OutputType,
	/**
	 * Fit mode to use when resizing tiles, if a tile needs to be resized.
	 * Default value: `ResizeFit.Cover`
	 */
	resizeFit?: ResizeFit,
	/**
	 * Kernel to use when resizing tiles, if a tile needs to be resized.
	 * Default value: `ResizeKernel.Nearest`
	 */
	resizeKernel?: ResizeKernel,

	/**
	 * Width of each tile in pixels.
	 * Default value: `128`
	 */
	tileWidth?: number,
	/**
	 * Height of each tile in pixels.
	 * Default value: `128`
	 */
	tileHeight?: number,
	/**
	 * Minimum count of tiles across the X axis.
	 * Default value: `0`
	 */
	minCountX?: number,
	/**
	 * Minimum count of tiles across the Y axis.
	 * Default value: `0`
	 */
	minCountY?: number,

	/**
	 * Log handler configuration.
	 * Used to specify callback functions for logging output.
	 * Default value: `undefined`
	 */
	logHandlers?: LogHandlerConfig
}

/**
 * Output structure containing data generated by the tilemap() function.
 * Contains the file data buffer, info about the tilemap, and info about the layout.
 */
export interface TilemapperOutput<LT> {
	/** Output data buffer. */
	data: Buffer;
	/** Output tilemap sizing information. */
	info: TilemapInfo;
	/** Layout information, contains information on a layout and its contents. */
	layout: LT;
}

// Values of various enums, for runtime checks
const valsOutputType:	string[] = Object.values(OutputType);
const valsResizeFit:	string[] = Object.values(ResizeFit);
const valsResizeKernel:	string[] = Object.values(ResizeKernel);
const valsLayoutMode:	string[] = Object.values(LayoutMode);

/** Generate a tilemap from input file/directory paths, outputs a buffer containing image data and various structures containing information about the generated tilemap */
export async function tilemap<
	LM extends LayoutMode.ListLayout | LayoutMode.SequenceLayout | LayoutMode.AnimationLayout,
	LT extends (
			LM extends LayoutMode.ListLayout	? Layout
		:	LM extends LayoutMode.SequenceLayout	? SequenceLayout
		:	LM extends LayoutMode.AnimationLayout	? AnimationLayout
		:	Layout | SequenceLayout | AnimationLayout
	)
>(
	/** Tilemapper options. */
	options?: TilemapperOptions<LM>
): Promise<TilemapperOutput<LT>> {
	// Type-check options object and paths + layoutMode
	if (typeof options !== "object")
		throw new Error("tilemap: Expected argument \"options\" to be an object");
	if (!Array.isArray(options.paths) && typeof options.paths !== "string")
		throw new Error("tilemap: Expected option \"paths\" to be a string or array of strings");
	if (!valsLayoutMode.includes(options.layoutMode!))
		throw new Error("tilemap: Expected option \"layoutMode\" to be a valid layout mode");

	// Set up log handlers if log handlers were provided
	let logHandlers: LogHandlerConfig | null = null;
	if (options.logHandlers) {
		if (typeof options !== "object")
			throw new Error("tilemap: Expected option \"logHandlers\" to be an object");

		logHandlers = { ...options.logHandlers };

		if (logHandlers.onDebug && typeof logHandlers.onDebug !== "function")
			throw new Error("tilemap: Expected log handler \"onDebug\" to be a function");
		if (logHandlers.onInfo && typeof logHandlers.onInfo !== "function")
			throw new Error("tilemap: Expected log handler \"onInfo\" to be a function");
		if (logHandlers.onWarn && typeof logHandlers.onWarn !== "function")
			throw new Error("tilemap: Expected log handler \"onWarn\" to be a function");

		logger.attachHandlers(logHandlers)
	}

	// Get input OutputType/ResizeFit/ResizeKernel
	const outputType: OutputType = options.outputType ?? OutputType.PNG;
	const resizeFit: ResizeFit = options.resizeFit ?? ResizeFit.Cover;
	const resizeKernel: ResizeKernel = options.resizeKernel ?? ResizeKernel.Nearest;
	// Type check those too!
	if (!valsOutputType.includes(outputType))
		throw new Error("tilemap: Expected option \"outputType\" to be a valid OutputType");
	if (!valsResizeFit.includes(resizeFit))
		throw new Error("tilemap: Expected option \"resizeFit\" to be a valid ResizeFit");
	if (!valsResizeKernel.includes(resizeKernel))
		throw new Error("tilemap: Expected option \"resizeKernel\" to be a valid ResizeKernel");

	if (options.extensions !== undefined && !Array.isArray(options.extensions))
		throw new Error("tilemap: Expected option \"extensions\" to be an array of strings");
	if (options.workingDirectory !== undefined && typeof options.workingDirectory !== "string")
		throw new Error("tilemap: Expected option \"workingDirectory\" to be a string");

	// Grab extensions and working directory
	const extensions: string[] | null = options.extensions?.map(String) ?? null;
	const workingDirectory: string | undefined = options.workingDirectory ?? undefined;

	// Get (and sanitize) paths and layoutMode
	const paths: string[] = [...(Array.isArray(options.paths) ? options.paths : [options.paths])].map(String);
	const layoutMode: LM = options.layoutMode!;

	// Walk through paths and generate path info
	const pathInfos: PathInfo[] = await walkPaths(paths, extensions, workingDirectory);
	if (pathInfos.length < 1)
		throw new Error("tilemap: Option \"paths\" matches no files");

	// Use those paths to generate a layout
	let layout: LT;
	switch (layoutMode) {
		case LayoutMode.ListLayout:
			layout = layoutList(pathInfos, options) as LT;
			break;
		case LayoutMode.SequenceLayout:
			layout = layoutSequences(pathInfos, options) as LT;
			break;
		case LayoutMode.AnimationLayout:
			layout = layoutAnimations(pathInfos, options) as LT;
			break;
		default:
			throw new Error("tilemap: Layout switch fallthrough");
	}
	if (layout.tileset.length < 1 || !layout.tileset[0] || layout.tileset[0].length < 1)
		throw new Error("tilemap: Generated layout contains no images");

	// Finally, composite that layout together into a tilemap!
	const [data, info] = await composite(
		layout.tileset,
		outputType,
		options.tileWidth, options.tileHeight,
		resizeFit, resizeKernel,
		options.minCountX, options.minCountY
	);

	// Clean up log handlers if required
	if (logHandlers) logger.detachHandlers(logHandlers);

	// And return the generated output data
	return { data, info, layout };
}
